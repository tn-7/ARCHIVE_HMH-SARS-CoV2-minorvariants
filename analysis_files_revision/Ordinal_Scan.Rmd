---
title: "R Notebook"
output: html_notebook
---
```{r}
source("./scripts/startup.R")
source("./scripts/load_data.R")
```



```{r}
library(lme4)
library(glmmTMB)
#install.packages("glmmTMB")
```
Define functions
```{r}
library(foreach); library(doParallel)

#setup parallel backend to use many processors

scale_scan_factors = function(patient_counts_30, scan_factors_trim) {
  p_sub = patient_counts_30 %>% 
  select(MCoVNumber,lineage,Duration,COLLECTION_DT:high_counts,
         one_of(scan_factors_trim)) %>% unique

  p_sub_scaled = p_sub %>% select(one_of(scan_factors_trim)) %>% 
    mutate_if(is.numeric, normalize) %>% # scale will z scale it, instead of the normalize fx above which is min max
    cbind(p_sub %>% select(!one_of(scan_factors_trim)))
  return(p_sub_scaled)
}

run_parallel_binom = function(tmp_counts, scan_factors_trim) {
  # define function that parallel needs
    parallel_binom = function(tmp_counts, scan_factors_trim, idx, model_type = "nbinom2") {
        if (model_type == "nbinom2") dv = "n_var" else dv = "high_counts"
        formula = formula(paste0(dv, "~", scan_factors_trim[idx], "+ CT + (1|run)"))
        flag = T
        model = tryCatch(glmmTMB(formula = formula, 
                         data = tmp_counts, family = model_type), 
                         error = function(e) flag <<- F)
        if (!flag) return(NULL)
        tmp = summary(model)
        model_coef = tmp$coefficients$cond %>% as.data.frame() %>% 
          select(Estimate, `Std. Error`, pval=`Pr(>|z|)`) %>% .[2,] %>% 
          mutate(model_type = model_type, 
                 high_counts = tmp_counts$high_counts_threshold[1],
                 name = scan_factors_trim[idx],
                 LL = Estimate - 1.96*`Std. Error`,
                 UL = Estimate + 1.96*`Std. Error`)
        return(model_coef)
    }
  
  # run the above function in parallel
  cores=detectCores()
  cl <- makeCluster(cores[1]-1) #not to overload your computer
  registerDoParallel(cl)
  finalMatrix <- foreach(idx=1:length(scan_factors_trim), .combine=rbind,
                         .packages=c("glmmTMB", "tidyverse")) %dopar% {
   tempMatrix_nb = parallel_binom(tmp_counts, scan_factors_trim, idx, model_type = "nbinom2")
   tempMatrix_binom = parallel_binom(tmp_counts, scan_factors_trim, idx, model_type = "binomial")

   tempMatrix_out = rbind(tempMatrix_nb, tempMatrix_binom)
   tempMatrix_out #Equivalent to finalMatrix = rbind(finalMatrix, tempMatrix)
  }
  stopCluster(cl)
  return(finalMatrix)
}

scale_and_run_binom = function(patient_counts_30, scan_factors_trim) {
  tmp_counts = scale_scan_factors(patient_counts_30, scan_factors_trim) %>% 
  mutate(high_counts_threshold = quantile(.$n_var, probs = .8)[[1]], 
         high_counts = n_var > high_counts_threshold)
  model_coef = run_parallel_binom(tmp_counts, scan_factors_trim)
  
  model_coef %>% 
  return(model_coef)
}

```

Run functions for negative binomial and binomial regression
``` {r}
scan_factors_trim = c('Duration','age18under','age55plus','sex','chronic_lung_disease',
                 'chronic_liver_disease', 'chronic_kidney_disease', 'chronic_heart_disease', 
                  'hypertension', 'diabetes', 'cancer', 'obesity', 
                 'plasma', 'mAb', 'admitted_hospital','vaccine_status',
                 'vocAlpha','vocDelta',
                 'surveillance','CT','median_coverage', 'PUI')

all_data = scale_and_run_binom(patient_counts_30, scan_factors_trim)
afterJuly = scale_and_run_binom(patient_counts_30 %>% 
                                   filter(collection_date >= "2021-07-01"), 
                                   scan_factors_trim)

afterJuly_IP = scale_and_run_binom(patient_counts_30 %>% 
                                   filter(admitted_hospital == 1 & 
                                            collection_date >= "2021-07-01"), 
                                   scan_factors_trim)
beforeJuly_IP = scale_and_run_binom(patient_counts_30 %>% 
                                   filter(admitted_hospital == 1 & 
                                            collection_date <= "2021-07-01"), 
                                   scan_factors_trim)
afterJuly_OP = scale_and_run_binom(patient_counts_30 %>% 
                                   filter(admitted_hospital == 0 & 
                                            collection_date >= "2021-07-01"), 
                                   scan_factors_trim)
beforeJuly_OP = scale_and_run_binom(patient_counts_30 %>% 
                                   filter(admitted_hospital == 0 & 
                                            collection_date <= "2021-07-01"), 
                                   scan_factors_trim)

dfnames = c("all_data", "afterJuly", "afterJuly_IP", "beforeJuly_IP", "afterJuly_OP", "beforeJuly_OP")
all_df_binom_nb = do.call(rbind, lapply(dfnames, function(x) cbind(get(x), Source=x)))
saveRDS(all_df_binom_nb, "ggsave/temp_all_df_binom_nb.txt")
```





```{r}
# Define functions

normalize <- function(x, na.rm = TRUE) {
  scaled = (x- min(x)) /(max(x)-min(x))
    return(scaled)
}



scan_factors_trim = c('Duration','age18under','age55plus','sex','chronic_lung_disease',
                 'chronic_liver_disease', 'chronic_kidney_disease', 'chronic_heart_disease', 
                  'hypertension', 'diabetes', 'cancer', 'obesity', 
                 'plasma', 'mAb', 'admitted_hospital','vaccine_status',
                 'vocAlpha','vocDelta',
                 'surveillance','CT','median_coverage','run', 'PUI')

unitable = function(patient_counts_uni, include, 
                    dv = "ordinal_counts", other_iv = NA) {
    index = 0; for (i in include) {
    flag = T
    index = index + 1
    if (!is.na(other_iv)){
        formulas_tmp = formula(paste0(dv, " ~", i, "+", other_iv))
    } else {
        formulas_tmp = formula(paste0(dv, " ~", i))
    }
    
     m <- tryCatch(mixed_model(formulas_tmp,
                              random = ~ 1 | run,
                              data = patient_counts_uni,
     family = binomial, control = list(iter_EM = 0)),
     error=function(e) flag<<-FALSE)
    
    if (!flag) next
    coef_table = summary(m)$coef_table
    # table of estimates with 95% CI
    tab <- cbind(estimate = coef_table[,1], 
                 se = coef_table[,2], pvalue = coef_table[,4]) %>%
                 #UL = coef_table[,1] + 1.96 * coef_table[,2]) %>%
      as.data.frame
    out_odds_tmp = (tab) %>% 
      mutate(pval = coef_table[,4]) %>% 
      .[-1,] %>% rownames_to_column
    if (index == 1) {
      out_odds = out_odds_tmp
    } else {
      out_odds = rbind(out_odds, out_odds_tmp)
    }
  }
  # out_odds = out_odds %>% arrange(pval) %>% 
  #   mutate(rowname = str_remove(rowname, "1"))
  # 
  # # count number of "YES" occurrences per column
  # YEScount = function(string) {
  #   return(sum(str_count(string, pattern = "1")))
  # }
  # 
  # counts = sapply(patient_counts_uni_tmp %>% 
  #                   filter(!is.na(.data[[dv]])), YEScount)
  # df_counts = data.frame(rowname = names(counts), counts)
  out = out_odds#%>% left_join(df_counts, by = "rowname")
  return(out)
}

```

# INITIAL SCAN
```{r}
library(ggforestplot)

actual_ordinal_scan = function(patient_counts_30) {
  p_sub_scaled = scale_scan_factors(
  patient_counts_30, 
  scan_factors_trim) %>% 
    mutate(ordinal_counts = cut(n_var, breaks = seq(0,30,5), right = F))
  all_dates = unitable(other_iv = "CT", p_sub_scaled, 
                       include = scan_factors_trim) %>% arrange(pval)
  before_july = unitable(other_iv = "CT", p_sub_scaled %>% 
                           filter(collection_date <= "2021-07-01"), 
                       include = scan_factors_trim) %>% arrange(pval)
  after_july = unitable(other_iv = "CT", p_sub_scaled %>% 
                           filter(collection_date >= "2021-07-01"), 
                       include = scan_factors_trim) %>% arrange(pval)
  
  initial_scan = rbind(all_dates %>% mutate(group = "all_dates"),
                       before_july %>% mutate(group = "before_July"),
                       after_july %>% mutate(group = "after_July"))
  
  
  order = initial_scan %>% filter(group == "all_dates") %>% 
    arrange(-estimate) %>% pull(rowname)
  initial_scan = initial_scan %>% arrange(estimate) %>%
    mutate(group = factor(group, 
                          levels = rev(c("before_July", "after_July",
                                            "all_dates")))) %>%
    filter(rowname != "CT")#,
           #rowname = factor(rowname, levels = rev(order)))
  return(initial_scan)
}

initial_scan = actual_ordinal_scan(patient_counts_30)


forest_simple = forestplot(initial_scan, rowname, estimate, se, 
                           pvalue, group) + 
  scale_color_manual(values = rev(c("lightblue", "salmon", "black"))) +
  scale_y_discrete(limits=rev) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, hjust=1)) + 
  theme(legend.position = "top", legend.direction = "vertical",
        legend.justification = "left")

forest_simple 
ggsave("ggsave/forest_simple.pdf", forest_simple, width = 4, height = 6)
```

#### INPATIENT VS OUTPATIENT BY DATE
```{r}
initial_scan_ip = actual_ordinal_scan(patient_counts_30 %>% filter(admitted_hospital == 1))

forest_ip = forestplot(initial_scan_ip, rowname, estimate, se, 
                           pvalue, group) + 
  scale_color_manual(values = rev(c("lightblue", "salmon", "black"))) +
  scale_y_discrete(limits=rev) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, hjust=1)) + 
  theme(legend.position = "top", legend.direction = "vertical",
        legend.justification = "left")

forest_ip


initial_scan_op = actual_ordinal_scan(patient_counts_30 %>% filter(admitted_hospital == 0))

forest_op = forestplot(initial_scan_op, rowname, estimate, se, 
                           pvalue, group) + 
  scale_color_manual(values = rev(c("lightblue", "salmon", "black"))) +
  scale_y_discrete(limits=rev) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, hjust=1)) + 
  theme(legend.position = "top", legend.direction = "vertical",
        legend.justification = "left")

forest_ip_op = ggarrange(forest_ip + ggtitle("Inpatient"), forest_op + ggtitle("Outpatient"), labels = list("A","B"),
                         common.legend = T)
forest_ip_op

ggsave("ggsave/forest_ip_op.pdf", forest_ip_op, width = 8, height = 6)
```

#### ALTERNATIVE DATASETS

```{r}
# No count restriction 
initial_scan_nocount = actual_ordinal_scan(patient_var_tmp %>% filter(n_var > 30, INSTRUMENT_RESULT > 26))

forest_nocount = forestplot(initial_scan_nocount, 
                                rowname, estimate, se, 
                           pvalue, group) + 
  scale_color_manual(values = rev(c("lightblue", "salmon", "black"))) +
  scale_y_discrete(limits=rev) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, hjust=1)) + 
  theme(legend.position = "top", legend.direction = "vertical",
        legend.justification = "left")

# 500x98%
initial_scan_500x98 = actual_ordinal_scan(patient_counts_30 %>% filter(fraction_500x_coverage > .98))

forest_500x98 = forestplot(initial_scan_500x98, 
                                rowname, estimate, se, 
                           pvalue, group) + 
  scale_color_manual(values = rev(c("lightblue", "salmon", "black"))) +
  scale_y_discrete(limits=rev) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, hjust=1)) + 
  theme(legend.position = "top", legend.direction = "vertical",
        legend.justification = "left")

# CT < 18
initial_scan_ct18 = actual_ordinal_scan(patient_counts_30 %>% filter(INSTRUMENT_RESULT < 18))

forest_ct18 = forestplot(initial_scan_ct18, 
                                rowname, estimate, se, 
                           pvalue, group) + 
  scale_color_manual(values = rev(c("lightblue", "salmon", "black"))) +
  scale_y_discrete(limits=rev) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, hjust=1)) + 
  theme(legend.position = "top", legend.direction = "vertical",
        legend.justification = "left")

forest_ct18

# No co-morbidity
initial_scan_no_comorbid = actual_ordinal_scan(patient_counts_30 %>% filter(admitted_hospital == 1))

forest_no_comorbid = forestplot(initial_scan_no_comorbid, 
                                rowname, estimate, se, 
                           pvalue, group) + 
  scale_color_manual(values = rev(c("lightblue", "salmon", "black"))) +
  scale_y_discrete(limits=rev) + 
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, hjust=1)) + 
  theme(legend.position = "top", legend.direction = "vertical",
        legend.justification = "left")

forest_no_comorbid

```


```{r}
forest_500x98
```

